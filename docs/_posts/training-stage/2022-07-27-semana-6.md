---
title: "Semana 6. Aframe"
categories:
  - Etapa de Entrenamiento
  - Julio
tags:
  - A-frame
  - JavaScript
youtubeId: 
---


Nos adentramos en la sexta semana del blog. Los retos indicados son:

> Utilizar Blender.

> Investigar sobre entidades padre-hijo con el fin de solucionar el problema de sincronización de las físicas. 

> Investigar sobre que ocurre cuando los usuarios introducen diferentes valores para las físicas. 


## **Blender**


## **Físicas**

* **Networked Aframe**

La semana pasada tuve una reunión con David Moreno, el cual me indico que el problema de sincronización de las físicas podría solucionarse a partir de el uso de entidades padre-hijo. Mediante este método se lograría que únicamente se modifique la posición y no las físicas. 

* Código utilizado anteriormente

El siguiente código es el utilizado hasta ahora, por ello, las físicas también son modificadas y al no ser deterministas dependen del procesador, lo que se traduce en que dependen de cada navegador. 

      <!-- Templates -->
      <a-assets>
        <template id="sphere-template">
          <a-entity 
          class="raycastable" 
          geometry="primitive: sphere" 
          material="color: red" 
          position="0 10 -10" 
          ></a-entity>
        </template>
      </a-assets>
      <!--
        Permmite visualizar el contenido en el navegador
      -->
      <a-entity id="sphere" 
        networked="template:#sphere-template;networkId:sphere;persistent:true;owner:scene">
      </a-entity>


* Código basado en entidades padre-hijo [Julio/6J/naf-tutorial/examples/291J.html](https://github.com/RoboticsLabURJC/2022-tfg-ana-villanueva/blob/main/otros/6J/naf-tutorial/examples/291J.html)

En el siguiente código tenemos una entidad padre que se dedicada a las físicas y una entidad hijo que engloba el resto y permite la sincronización. 

      <!-- 
        Templates 
      -->
      <a-assets>
        <template id="sphere-template">
          <a-entity 
          class="raycastable" 
          geometry="primitive: sphere" 
          material="color: red" 
          position="0 100 -10" 
          ></a-entity>
        </template>
      </a-assets>
      <!--
        Permmite visualizar el contenido en el navegador
      -->
      <a-entity
        id="sphereP">
        <a-entity id="sphere" 
          networked="template:#sphere-template;networkId:sphere;persistent:true;owner:scene">
        </a-entity>
      </a-entity>

{% include video id="169fib6mckg" provider="youtube" %}
       

* Código basado en entidades padre-hijo [Julio/6J/naf-tutorial/examples/292J.html](https://github.com/RoboticsLabURJC/2022-tfg-ana-villanueva/blob/main/otros/6J/naf-tutorial/examples/292J.html)

En el siguiente código tenemos una entidad hijo que se dedicada a las físicas y una entidad padre que engloba el resto y permite la sincronización. 

      <!-- 
        Templates 
      -->
      <a-assets>
        <template id="sphere-template">
            <a-entity 
            class="raycastable" 
            geometry="primitive: sphere" 
            material="color: red" 
            position="0 5 -10" 
            ></a-entity>
        </template>
      </a-assets>
      <!--
        Permmite visualizar el contenido en el navegador
      -->
      <a-entity
      id="sphere" 
      networked="template:#sphere-template;networkId:sphere;persistent:true;owner:scene">
        <a-entity
        id="sphereP">
        </a-entity>
      </a-entity>

{% include video id="pdPnMhnlRjg" provider="youtube" %}

Notas: 
*No veo que haya una mejora en la sincronización de las entidades*

*NAF.utils.takeOwnership(this.floor); y NAF.utils.takeOwnership(this.sphere); permiten la sincronización de un componente entre navegadores, pero si nos encontramos ante entidades padre-hijo debería no ser necesario ponerlo, ya que lo que se comparte es el cambio de posición y no las físicas. El problema esta en que si las físicas no son compartidas la entidad del otro navegador no cambia de posición* 

Por tanto, las notas anteriores me han llevado a experimentar con animaciones. He observado, de nuevo, que sin *NAF.utils.takeOwnership(this.sphere);* no sincroniza este nuevo atributo, por tanto, no se modifica la posición de la esfera y únicamente varía en el navegador que estamos modificando. Esto me ha llevado a la conclusión de que es necesario enviar los cambios de posición. 

          this.sphere.setAttribute('position', {
            x: this.sphere.getAttribute('position').x,
            y: this.sphere.getAttribute('position').y,
            z: this.sphere.getAttribute('position').z
        });

        NAF.utils.takeOwnership(this.sphere);

Pero, ¿enviar estos cambios de posición mejora la sincronización entre los navegadores?


* **Aframe - Entidades padre-hijo - Cambios de posición**

A partir de ejemplos anteriores he llegado a la conclusión de que la entidad padre únicamente otorga a la entidad hijo la posición, por ello, hemos de coordinar la posición entre navegadores. 

    <a-entity id="movement" 
      networked="template:#movement-template;networkId:movement;persistent:true;owner:scene">

        <a-entity id="sphere" 
        networked="template:#sphere-template;networkId:sphere;persistent:true;owner:scene">
        </a-entity>

    </a-entity>

¿Cómo coordinar la posición entre navegadores?

1. Uso de *setInterval*.

Mediante el uso de *setInterval* podemos obtener los cambios de posición de nuestra esfera, pero no observo continuidad, sino un movimiento a parches. [Julio/6J/examples/302.html]

{% include video id="Zh_KhFwRR1w " provider="youtube" %}

Nota: *Parece que si pongo en myCallBack la sincronización de la esfera mejora la situación, muy ligeramente.*

2. Uso de *tick* [Julio/6J/examples/303.html]

*Tick:* Llamado en cada bucle de renderizado o marca de la escena. Se utiliza para cambios o controles continuos.

Mediante el uso de *tick* podemos observar cambios de posición en nuestra esfera. En función del instante existe mayor o menor continuidad. No soluciona el problema, ya que el usuario visualizaria el contenido a trompicones e incluso en ocasiones se queda congelado.  

La función *tick* no permite usar el prefijo *this.*, por ello, he introducido en su interior una función denominada *exchange*, que si lo permite y noto cierta mejora, aunque no es perfecto. 

{% include video id="SUvWn_d1SI0" provider="youtube" %}

Notas: 

*En Aframe básico funciona sin problemas*
*Cuando grabo la pantalla se realentiza mucho el movimiento en el navegador que solo recibe los cambios de movimiento*

* **Networked Aframe - Físicas**

¿Al compartir las físicas entre navegadores realmente se visualizan de manera diferente en los distintos navegadores?

Según se me ha comentado las físicas son deterministas, por ello, en los resultados deberían ser diferentes en los distintos navegadores. Al intentar enviar los cambios de posición he observado que es prácticamente imposible que los movimientos se den en el mismo instante, es decir, hay un pequeño *delay* entre navegadores. ¿No podría ser este pequeño *delay* sea lo que este ocurriendo al compartir las físicas?
Al realizar ejemplos en *Aframe* observo que cada vez que refresco la página el resultado de las físicas es distinto, pero esto no ocurre en nuestros navegadores al usar *Networked aframe*, es decir, visualizo exactamente el mismo movimiento, pero con cierto retardo. 

[Julio/6J/304J.html]

{% include video id="OkUZf8G_4_c " provider="youtube" %}

[Julio/30J/phy_ex2.html]

{% include video id="W2jEeJyicm8 " provider="youtube" %}




* **Networked Aframe - ¿Qué ocurre cuando los usuarios introducen diferentes valores en las físicas?**