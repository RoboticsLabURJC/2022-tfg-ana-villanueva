---
title: "Semana 15. Kibotic-Websim"
categories:
  - Etapa de Entrenamiento
  - Noviembre
tags:
  - Kibotic-Websim
youtubeId: 
---


Nos adentramos en la decimoquinta semana del blog. Los retos indicados son:

> Trastear con D1 

# Trastear con D1

* Sensores

* Motores

Se han de tener en cuenta las maneras del manejo del robot. Por un lado, movimiento en velocidad y, por otro lado, movimiento en posición.

> Movimiento en velocidad (investigar)

Determina las velocidades deseadas. Existen dos niveles por debajo.

- Controlador

Se tiene en cuenta la velocidad deseada y, en caso de no alcanzarla se aumenta la fuerza autónoma. Por tanto, traducción velocidad -> fuerza autónoma. 

- Motor de físicas 

Se trata de la combinación entre la fuerza autónoma del objeto y el motor de físicas de A-frame.

Por ejemplo: Avanza a X velocidad

> Movimiento en posición (olvidar)

Tan sencillo como un bucle que busca la llegada a una posición concreta y en caso de que no se haya llegado a la misma se mantiene la velocidad. 

Por ejemplo: Avanza X metros + Gira X grados

¿Por donde empezar? Búsqueda de funciones robotAPI, las invoca el usuario, y búsqueda funciones tick. Por tanto, una vez tenido todo esto en cuenta iniciamos la búsqueda observando en github los *motor interfaces*.

| Método | Descripción |
| setV | Establece la velocidad linear | 
| setW | Establece la velocidad angular | 
| setL | Establece la velocidad de elevación | 
| move | Establece la velocidad linear y angular | 
| getV | Devuelve la velocidad linear dada | 
| getW | Devuelve la velocidad angular dada | 
| getL | Devuelve la velocidad de elevación dada | 
| getRotation | Devuelve la rotación en los ejes | 

- robots\robotAPI\HALRobotAPI.js

Definición y exportación de las funciones mencionadas anteriormente. 

¿Dónde son exportadas? Concretamente parecen ser exportadas a robots\interfacesRobot.js

> robotI(objeto).prototype(permite heredar caracterísitcas).método

Por tanto, me parece que se llega a un camino sin salida. 

- robots\interfacesRobot.js

**Controlador: Se tiene en cuenta la velocidad deseada y, en caso de no alcanzarla se aumenta la fuerza autónoma. Por tanto, traducción velocidad -> fuerza autónoma.**

Existen 4 controladores PD que se ejecutan en función:

1. Ubicación del robot (terrestre vs aereo)
2. Movimiento del robot (avance lineal, giro, vuelo o suspensión en el aire)

DRONE

* controllerPDVerticalVel

Toma la velocidad deseada y la velocidad entrante del plano vertical en ese instante para generar como salida la fuerza que se debe ejercer para alcanzar la velocidad objetivo. 

¿De dónde proviene la velocidad entrante del plano vertical? Realmente no parece tomar una velocidad, ya que la función no tiene parámetros de entrada.

* controllerPDVerticalPos

Toma la componente vertical de posición en ese instante y genera como salida la fuerza que debe ejercer el robot para mantener la posición de referencia. Se usa cuando la velocidad deseada es cero. 

ROBOT TERRESTRE 

* controllerPDHorizontal

Toma la velocidad deseada y la velocidad entrante del plano horizontal en ese instante para generar como salida la fuerza que se debe ejercer para alcanzar la velocidad objetivo. 

¿De dónde proviene la velocidad entrante del plano horizontal?

* controllerPDAngular

Toma la velocidad deseada de guiñada y la velocidad angular entrante en este instante para generar como salida el torque que debe ejercer el robot para alcanzar la velocidad de giro objetivo.



**Motor de físicas - Se trata de la combinación entre la fuerza autónoma del objeto y el motor de físicas de A-frame.**

* auxiliaryPhysics